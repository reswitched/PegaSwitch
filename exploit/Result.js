var utils = require('./utils');

var emptyOk;

class Result {
	constructor(isOk, value) {
		this.isOk = isOk;
		this.value = value;
	}

	/*
    If this result is not Ok, throw the error. If it is, return the value.
    Example:
      sc.svcCloseHandle(handle).assertOk();
      var thread = sc.svcCreateThread(...).assertOk();
    Throws:
      The error, if this is an Err result.
    Returns:
      The value, if this is an Ok result.
   */
	assertOk() {
		if(!this.isOk) {
			if(this.value) {
				throw new Error(this.value);
			} else {
				throw new Error("no error?");
			}
		}
		return this.value;
	}

	/*
    If this result is not Err, throw an error. If it is, return the error.
    Example:
      var err = sc.svcConnectToPort("bad port").assertError();
    Throws:
      new Error("expected error but was successful") if this is an Ok result.
    Returns:
      The error, if this is an Err result.
   */
	assertError() {
		if(this.isOk) {
			throw new Error("expected error but was successful");
		}
		return this.value;
	}

	/*
    Convenience function for working with ResultCodes. Expects a certain error code.
    Example:
      sc.svcCloseHandle(0).assertErrorCode(0xe401);
    Throws:
      new Error("expected error but was successful") if this is an Ok result.
      new Error("expected error code"...) if the error code does not match.
    Returns:
      The numeric error code.
   */
	assertErrorCode(expected) {
		expected = utils.trunc32(expected);
		var code = utils.trunc32(this.assertError().resultCode);
		if(code === expected) {
			return this.value;
		} else {
			throw new Error("expected error code 0x" + expected.toString(16) + ", got " + code.toString(16));
		}
	}

	/*
    map(f):
      Transform an Ok value, but pass through an Err value.
      Returns:
        A new Ok result with the return value of the mapping function if the
        original Result was Ok. Otherwise, the same Err result.
    map(f, e):
      Transform both an Ok value and an Err value.
      Returns:
        If Ok, return new Ok with the return value of the Ok mapping function.
        If Err, return new Err with the return value of the Err mapping function.
   */
	map(f, e) {
		if(this.isOk) {
			return new Ok(f(this.value));
		} else {
			if(e !== undefined) {
				return new Err(e(this.value));
			} else {
				return this;
			}
		}
	}

	/*
    Transform an Err value, but pass through an Ok value.
   */
	mapErr(e) {
		if(this.isOk) {
			return this;
		} else {
			return new Err(e(this.value));
		}
	}

	/*
		If Ok, return new Err with the value.
		If Err, return new Ok with the error.
		Useful for if you expect an error and to not get one is a real error.
	*/
	invert() {
		if(this.isOk) {
			return new Err(this.value);
		} else {
			return new Ok(this.value);
		}
	}

	/*
		If Ok and f(this.value) is also Ok, return Ok(f(this.value)).
		Otherwise, return Err(this.value)
	 */
	andThen(f) {
		if(this.isOk) {
			return f(this.value);
		} else {
			return this;
		}
	}
  
	/*
    Shorthand for .map(() => nv). Discards the original Ok value, useful for if it was
    going to be `undefined` anyway.
   */
	replaceValue(nv) {
		if(this.isOk) {
			return new Ok(nv);
		} else {
			return this;
		}
	}

	/*
    Get the value if this is an Ok result, otherwise null.
   */
	getValue() {
		return this.isOk ? this.value : null;
	}

	/*
    Get the error if this is an Err result, otherwise null.
   */
	getError() {
		return !this.isOk ? this.value : null;
	}

	/*
    If this is Ok, return the value. Otherwise, return v.
   */
	unwrapOrElse(v) {
		if(this.isOk) {
			return this.value;
		} else {
			return v;
		}
	}

	toString() {
		return "Result<" + (this.isOk ? "Ok" : "Err") + ">(" + this.value + ")";
	}
}

class Ok extends Result {
	constructor(value) {
		super(true, value);
	}
}

class Err extends Result {
	constructor(value) {
		super(false, value);
	}
}

module.exports = {Result, Ok, NullOk: new Ok(), Err};
