/*
	requires spl MITM and ro!ease_nro_restriction = 0x1
*/

var utils = require("./utils")

module.exports = (res, args) => {
	if(!sc.sdb) {
		throw new Error("requires spl mitm. try `enable sdbcore`");
	}
	if(sc.version !== "3.0.0") {
		throw new Error("requires 3.0.0");
	}
	
	var nrr = new ArrayBuffer(0x1000);
	var nrru32 = new Uint32Array(nrr);
	nrru32[0] = 0x3052524E; // NRR0
	nrru32[(0x338 >> 2) + 0] = 0x1000; // Size
	nrru32[(0x340 >> 2) + 0] = 0x350; // Hash offset
	nrru32[(0x340 >> 2) + 1] = 0x1; // Hash count
	
	while(res.length & 0xFFF)
		res.push(0);
	var u8 = new Uint8Array(res);
	var u32 = new Uint32Array(u8.buffer);

	var nroSize = u32[0x18 >> 2];
	var bssSize = u32[0x38 >> 2];
	var mod0Offset = u32[1];
	var dynamicOffset = mod0Offset + u32[(mod0Offset >> 2) + 1];

	utils.log("dynamic offset: 0x" + dynamicOffset.toString(16));

	crypto.subtle.digest("SHA-256", u8.buffer).then((hash) => {
		var nrrhashu8 = new Uint8Array(nrr, 0x350, 32);
		var hashu8 = new Uint8Array(hash);
		nrrhashu8.set(hashu8);
		
		sc.getService("ldr:ro", (ldrro) => {
			var nrraddr = sc.getArrayBufferAddr(nrr);
			sc.ipcMsg(4).datau64(0).sendPid().copyHandle(0xffff8001).sendTo(ldrro).assertOk();
			sc.ipcMsg(2).datau64(0, nrraddr, nrr.byteLength).sendPid().sendTo(ldrro).show();
			
			var nrobase = sc.malloc(u8.length + bssSize + 0xfff);
			if(nrobase[0] & 0xFFF)
				nrobase[0] = ((nrobase[0] & 0xFFFFF000) + 0x1000) >>> 0;
			
			sc.memcpy(nrobase, u8, u8.byteLength);
			
			sc.svcNroBase = sc.ipcMsg(0).datau64(0, nrobase, nroSize, utils.add2(nrobase, nroSize), bssSize).sendPid().sendTo(ldrro).assertOk().data;

			sc.ipcMsg(3).datau64(0, nrraddr).sendPid().sendTo(ldrro).assertOk();
			
			utils.log('NRO loaded at ' + utils.paddr(sc.svcNroBase));

			if(args === undefined) {
				args = [];
			}
			var argAbs = args.map((arg) => utils.str2ab(arg));
			var argv = new Uint32Array(argAbs.length * 2);
			for(var i = 0; i < argAbs.length; i++) {
				var addr = sc.getArrayBufferAddr(argAbs[i]);
				argv[(i*2)+0] = addr[0];
				argv[(i*2)+1] = addr[1];
			}
			utils.hexdump("argv", argv);

			var argvAddr = sc.getArrayBufferAddr(argv);

			var magic = utils.parseAddr("007874635f656361");
			var appHeap = new ArrayBuffer(0x400000);
			var appHeapAddr = sc.getArrayBufferAddr(appHeap);
			
			var libtransistorContext = new Uint32Array([
				magic[0], magic[1],
				3, 0, // version
				0, 0, // size (written in later)

				0, 0, // OUT char *log_buffer
				0, 0, // OUT size_t *log_size

				argvAddr[0], argvAddr[1], // IN char **argv
				argAbs.length, 0, // IN uint64_t argc

				appHeapAddr[0], appHeapAddr[1], // IN void* mem_base
				appHeap.byteLength, 0, // IN uint64_t mem_size

				0, // IN bool has_bsd
				0, // padding
				0, 0, 0, 0, // IN ipc_object_t bsd_object
				0, // IN int std_socket

				0, // IN bool has_ro
				0, 0, 0, 0, // IN ipc_object_t ro_object

				0, // workstation_addr
				0, // padding
				
				0, 0, // OUT return_flags

				0, // IN thread_h main_thread
				0, // padding
			]);
			libtransistorContext[4] = libtransistorContext.byteLength;
			
			utils.log("closing sm and jumping...");
			sc.svcCloseHandle(sc.smHandle).assertOk();
			sc.smHandle = undefined;
			utils.log("returned " + utils.paddr(sc.call(utils.add2(sc.svcNroBase, 0x80), [0, 0, libtransistorContext])));
			
			var logBufferAddr = [libtransistorContext[6], libtransistorContext[7]];
			var logLengthAddr = [libtransistorContext[8], libtransistorContext[9]];
			utils.log("log buffer: " + utils.paddr(logBufferAddr));
			
			if(logBufferAddr[0] == 0 && logBufferAddr[1] == 0) {
				utils.log("context was not populated");
			} else {
				utils.log("LOG:");
				sc.memview(logBufferAddr, sc.read4(logLengthAddr), (logab) => {
					utils.log(utils.u8a2nullstr(new Uint8Array(logab)));
				});
				
				var flagsLo = libtransistorContext[32];
				if((flagsLo & 4) > 0) { // RETF_CLOSE_BROWSER
					window.close();
				}
			}
		});
	}).catch((e) => {
		utils.log("error in then()");
		window.onerror(e.message, null, e.line, null, e);
	});
};
