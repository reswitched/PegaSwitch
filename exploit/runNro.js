/*
	requires spl MITM and ro!ease_nro_restriction = 0x1
*/

var utils = require("./utils")

module.exports = (res, args) => {
	if(!sc.sdb) {
		throw new Error("requires spl mitm. try `enable sdbcore`");
	}
	if(sc.version !== "3.0.0") {
		throw new Error("requires 3.0.0");
	}
	
	var nrr = new ArrayBuffer(0x1000);
	var nrru32 = new Uint32Array(nrr);
	nrru32[0] = 0x3052524E; // NRR0
	nrru32[(0x338 >> 2) + 0] = 0x1000; // Size
	nrru32[(0x340 >> 2) + 0] = 0x350; // Hash offset
	nrru32[(0x340 >> 2) + 1] = 0x1; // Hash count
	
	while(res.length & 0xFFF)
		res.push(0);
	var u8 = new Uint8Array(res);
	var u32 = new Uint32Array(u8.buffer);

	var nroSize = u32[0x18 >> 2];
	var bssSize = u32[0x38 >> 2];
	var mod0Offset = u32[1];
	var dynamicOffset = mod0Offset + u32[(mod0Offset >> 2) + 1];

	utils.log("dynamic offset: 0x" + dynamicOffset.toString(16));

	return crypto.subtle.digest("SHA-256", u8.buffer).then((hash) => {
		var nrrhashu8 = new Uint8Array(nrr, 0x350, 32);
		var hashu8 = new Uint8Array(hash);
		nrrhashu8.set(hashu8);
		
		return sc.getService("ldr:ro", (ldrro) => {
			var nrraddr = sc.getArrayBufferAddr(nrr);
			sc.ipcMsg(4).datau64(0).sendPid().copyHandle(0xffff8001).sendTo(ldrro).assertOk();
			sc.ipcMsg(2).datau64(0, nrraddr, nrr.byteLength).sendPid().sendTo(ldrro).show();
			
			var nrobase = sc.malloc(u8.length + bssSize + 0xfff);
			if(nrobase[0] & 0xFFF)
				nrobase[0] = ((nrobase[0] & 0xFFFFF000) + 0x1000) >>> 0;
			
			sc.memcpy(nrobase, u8, u8.byteLength);
			
			sc.svcNroBase = sc.ipcMsg(0).datau64(0, nrobase, nroSize, utils.add2(nrobase, nroSize), bssSize).sendPid().sendTo(ldrro).assertOk().data;

			sc.ipcMsg(3).datau64(0, nrraddr).sendPid().sendTo(ldrro).assertOk();
			
			utils.log('NRO loaded at ' + utils.paddr(sc.svcNroBase));

			if(args === undefined) {
				args = [];
			}
			var argAbs = args.map((arg) => utils.str2ab(arg));
			var argv = new Uint32Array(argAbs.length * 2);
			for(var i = 0; i < argAbs.length; i++) {
				var addr = sc.getArrayBufferAddr(argAbs[i]);
				argv[(i*2)+0] = addr[0];
				argv[(i*2)+1] = addr[1];
			}
			utils.hexdump("argv", argv);

			var argvAddr = sc.getArrayBufferAddr(argv);

			var magic = utils.parseAddr("007874635f656361");
			var appHeap = new ArrayBuffer(0x400000);
			var appHeapAddr = sc.getArrayBufferAddr(appHeap);

			var loaderConfig = new Uint32Array([
				3, // key (OverrideHeap)
				1, // flags ([RECOGNITION-MANDATORY])
				appHeapAddr[0], appHeapAddr[1], // value[0]
				appHeap.byteLength, 0, // value[1]

				5, // key (Argv)
				0, // flags
				argAbs.length, 0, // value[0]
				argvAddr[0], argvAddr[1], // value[1]

				8, // key (AppletWorkaround)
				1, // flags ([RECOGNITION-MANDATORY])
				0, 0, // value[0] (aruid)
				0, 0, // value[1] (ignored)
				
				0, // key (EndOfList)
				1, // flags ([RECOGNITION-MANDATORY])
				0, 0, 0, 0, // value[0], (ignored) value[1] (ignored)
			]);
			
			utils.log("closing sm and jumping...");
			sc.svcCloseHandle(sc.smHandle).assertOk();
			sc.smHandle = undefined;
			var ret = sc.call(sc.svcNroBase, [loaderConfig]);
			utils.log("returned " + utils.paddr(ret));
			return ret;
		});
	}).catch((e) => {
		utils.log("error in then()");
		window.onerror(e.message, null, e.line, null, e);
	});
};
